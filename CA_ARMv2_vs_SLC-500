ARMv2 vs SLC-500 Comparison

Elementary Base and Physical Characteristics

The elementary base of the ARMv2 architecture was Very Large Scale Integration (VLSI), specifically realized in the VL86C010 microprocessor. Designed by Acorn Computers and manufactured by VLSI Technology Inc., this 32-bit Reduced Instruction Set Computer (RISC) chip was fabricated using a 2.0 µm CMOS process (VLSI Technology Inc., 1987). The processor contained 27,000 transistors and featured a die size of 34.13 mm² (5.842 mm × 5.842 mm) (Furber, 2000). It was packaged in an 84-pin Plastic Leaded Chip Carrier (PLCC-84) measuring approximately 29.41 mm by 30.35 mm. While the chip was rated for clock frequencies of 10 MHz or 12 MHz, early implementations often utilized it at 8 MHz. Regarding power consumption, the manufacturer’s datasheet specified a maximum power dissipation of 2 Watts (VLSI Technology Inc., 1987). This figure represented the thermal limit of the package rather than typical usage. In practice, when operating within standard parameters, the chip was highly efficient, drawing approximately 0.1 Watts (100 mW) (Furber, 2000). This low power draw allowed the processor to operate without a heatsink. The equipment built around this processor, such as the Acorn Archimedes A300 series, typically followed a desktop form factor with separate peripherals. The main unit of the A310 measured 362mm in width, 406mm in depth, and 97mm in height, and it was powered by a 50-watt power supply unit. Later models like the Acorn Archimedes A3000 integrated the motherboard and keyboard into a single "all-in-one" chassis. This unit measured 470mm by 380mm and ran on an internal power supply rated at 22 Watts.

In contrast, the elementary base of the SLC 500 is a modular, chassis-based programmable controller system rather than a single-chip implementation. The system is composed of a processor module, power supply, and I/O modules housed in a 4, 7, 10, or 13-slot chassis (Rockwell Automation, 2013 ). The processor modules, such as the SLC 5/03, 5/04, and 5/05, utilize modern solid-state microprocessors and Large Scale Integration (LSI) components designed to withstand industrial vibration, thermal extremes, and electrical noise (Rockwell Automation, 2013 ). Physically, the equipment is ruggedized for back-panel mounting; for example, a 4-slot modular chassis measures approximately 158mm in height, 171mm in width, and 145mm in depth (Rockwell Automation, 2013 ). Power consumption is dependent on the specific modules used; for instance, an SLC 5/03 processor draws 500 mA at 5V DC from the backplane, while an SLC 5/05 draws 1000 mA at 5V DC (Rockwell Automation, 2013 ). The system requires a dedicated power supply (e.g., 1746-P1) capable of handling high inrush currents up to 20 A (Rockwell Automation, 2013 ).

Architecture Type

The ARMv2 architecture, utilized in the VL8C010 processor, was a General Purpose Register (GPR) architecture (Seal, 200). This design was different from accumulator-based architectures or stack-based architecture. In the ARMv2 design, the processor could not perform arithmetic of logical operations directly  on memory addresses. Instead, al processing happened within the internal register file. Data had to be explicitly loaded from memory into a register before it could be manipulated, and the results had to be stored back to memory using separate instructions (Furber, 2000). This architecture relied on a bank of 27 physical 32 bit registers, but the programmer generally accessed a set of 16 logical registers (R0 through R15) in any given processor mode. A specific characteristic of the ARMv2 implementation was the usage of register R15. This register functioned as the Program Counter (PC), but also contained the Processor Status Register flags in the upper bits. This dual usage of R15 restricted the addressable memory space to 26 bits or 64 MB (Seal, 2000).


The SLC 500 architecture operates primarily as a memory-to-memory machine from the programmers perspective, utilizing a proprietary scanning architecture optimized for logic solving. The processor provides control through a processor file composed of Program Files and Data Files such as Output, Input, Status, Binary, Timer, Counter, Control, Integer, and Float (Rockwell Automation, 2008). Instructions typically operate directly on these data files rather than loading data into general-purpose registers first. For example, mathematical instructions take input values from specific memory addresses, perform the operation, and output the result to a destination memory address (Rockwell Automation, 2008).

Machine Address Format

The ARMv2 architecture is strictly classified as a three-address machine (Seal, 2000). Data processing instructions explicitly specify three distinct operands: a destination register (Rd) and two source operands (Rn and Operand2). For example, the instruction ADD R0, R1, R2 calculates the sum of R1 and R2 and places the result into R0.

The SLC 500 also functions largely as a three-address machine for its arithmetic and logical operations. Majority of the instructions, such as ADD and SUB, take two input values (Source A and Source B) and place the result in a specified Destination address (Rockwell Automation, 2008 ). Some instructions, however, utilize a two-address format, such as the MOV instruction, which moves a Source value to a Destination location (Rockwell Automation, 2008a ), or the NEG instruction, which changes the sign of a Source and places it in a Destination (Rockwell Automation, 2008 ).

Registers

The ARMv2 architecture was a Load/Store machine utilizing a set of 32-bit General Purpose Registers (GPR), it had 27 physical registers. Using called register banking, the processor exposed only 16 logical registers (R0 through R15) to the programmer at any one time, swapping specific physical registers automatically during mode switches to isolate interruption contexts (Furber, 2000). While for the most part it was general-purpose, specific registers held specialized roles. For example R13 served by convention as a Stack Pointer, R14 acted as a Link Register for return addresses, and R15 uniquely combined the Program Counter and Processor Status Register into a single 32-bit value (Seal, 2000).

The SLC 500 does not utilize General Purpose Registers in the traditional sense. Instead, it uses a Data Table organized into specific file types that act as memory-mapped registers (Rockwell Automation, 2008a ). For example, the Status File (S2) stores controller operation information, and the Integer File (N7) is used to store numeric values (Rockwell Automation, 2008a ). The system does utilize specific internal registers for math operations; Status word S:13 and S:14 act as a "Math Register" to store the 32 bit results of multiply instructions or the remainder/quotient of divide instructions (Rockwell Automation, 2008a ). Additionally, an Index Register (S:24) is provided to store offset values for indexed addressing operations (Rockwell Automation, 2008a ).


Flags

The ARMv2 architecture used status flags to indicate arithmetic results and control program flow. These flags resided in the upper six bits of register R15, with the Program Counter. The four condition flags were N (Negative), Z (Zero), C (Carry), and V (Overflow) (Seal, 2000). Instructions updated these flags only when the "S" bit was set in the opcode. R15 also held two interrupt disable flags, I (IRQ Disable) and F (FIQ Disable). Placing these flags within the PC register made sure that saving R15 automatically preserved the processor status during interrupts or other subroutine calls.

The SLC 500 utilizes arithmetic status flags located in Word 0 of the Status File (S:0) (Rockwell Automation, 2008a ). These flags include the Carry (C) bit (S:0/0), which is set if a carry is generated; the Overflow (V) bit (S:0/1), which sets if a result does not fit in the destination; the Zero (Z) bit (S:0/2), which sets if a result is zero; and the Sign (S) bit (S:0/3), which sets if a result is negative (Rockwell Automation, 2008a ). Additionally, a Minor Error bit (S:5/0) serves as an overflow trap bit to detect mathematical overflows (Rockwell Automation, 2008a ).

Machine Word Width

The ARMv2 was a 32-bit architecture with a native machine word of 32 bits. All internal registers, the Arithmetic Logic Unit (ALU), and the external data bus measured 32 bits (Furber, 2000). This design enabled the manipulation of 32-bit integers in a single instruction cycle. The architecture supported 8-bit byte and 32-bit word data transfers but lacked native support for 16-bit half-word transfers. While the data path was 32 bits wide, the addressable memory space was restricted to 26 bits (64MB) because the upper and lower bits of the Program Counter were used for the status flags.

The SLC 500 architecture is based on a 16-bit machine word. Input, Output, Status, and Integer files are all composed of 16-bit elements (Rockwell Automation, 2008a ). However, the architecture supports 32-bit operations synthetically. For example, Floating Point (F8) data files use 2-word elements (32 bits per element) to store single-precision numbers (Rockwell Automation, 2008a ). Furthermore, the Math Overflow Selection Bit (S:2/14) allows the processor to perform 32-bit signed math by cascading calculations across 16-bit words (Rockwell Automation, 2008a ).

























